<h1>Functions</h1>

<h2>Files and IO functions</h2>

<h3>FileExcension</h3>

<p>
	Splits file name to name and extension:
</p>
<p class="alert alert-dark code">
	<code>
		FileExtension <v>ext</v> = <k>new</k> FileExtension(<w>"some-name.txt"</w>); <br>
		String <v>name</v> = <v>ext</v>.getName();<br>
		String <v>extension</v> = <v>ext</v>.getExtension();
	</code>
</p>

<h3>FilesList</h3>

<p>
	Loads file names from directory. Can be recursive or not. Is able to load names from directory in file system and from jar file.
</p>
<p class="alert alert-dark code">
	<code>
		FilesList <v>filesList</v> = FilesList.get(<w>"/path/to/dir/name"</w>, <k>true</k>); <c>// second parameter says 'recursive'</c> <br>
		List&lt;String&gt; <v>files</v> = <v>filesList</v>.getFiles(); <br>
		URL <v>url</v> = <v>filesList</v>.getURL();
	</code>
</p>

<h3>InputStreamLoader</h3>

<p>
	Creates new instance of <code>InputStream</code> from file. File can be in file system, classpath (in IDE) or in jar. <strong>Path to file has to be relative without first '/'.</strong> 
</p>
<p class="alert alert-dark code">
	<code>
		InputStream <v>inputStream</v> = InputStreamLoader.<i>createInputStream</i></fieldset>(<k>this</k>.getClass(), <w>"path/to/file"</w>);
	</code>
</p>

<h3>PropertiesLoader</h3>

<p>
	Loads <code>Properties</code> from file using <code>InputStreamLoader</code> (means file can be in file system or jar).
</p>
<p class="alert alert-dark code">
	<code>
		Properties <v>prop</v> = PropertiesLoader.<i>loadProperties</i>(<w>"res/app.properties"</w>); <br>
		<c>// optionally with charset, default 'uft-8'</c> <br>
		Properties <v>prop</v> = PropertiesLoader.<i>loadProperties</i>(<w>"res/app.properties"</w>, <w>"windows-1250"</w>);
	</code>
</p>

<h2>Mapper</h2>

<p>
	<code>Mapper</code> class is able to convert object (entity) to <code>Map</code> (serialize) and <code>Map</code> back to entity (parse).
</p>

<h3>Serialize</h3>

<p>
	During serialization JI come thru all fields of entity and uses then as key in new <code>Map</code>. Values of fields become values. Serializations works recursivelly. If you wish ignore field during serialization, just add <code>MapperIgnored</code> annotation. If you do not wish use field name as key, you need to annotate this field with <code>MapperParameter</code> and as value to put <code>MapperType</code> (see examples).
</p>

<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	<k>public class</k> UserEntity { <br>
		<t></t><d>@MapperParameter</d>({<d>@MapperType</d>(<w>"user_id"</w>)}) <br>
		<t></t><k>private</k> <k>int</k> <f>id</f>; <c>// this field will be saved as 'user_id'</c> <br>
		<t></t> <br>
		<t></t><k>private</k> String <f>name</f>; <c>// this field will be saved as 'name'</c> <br>
		<t></t><d>@MapperIgnored</d> <br>
		<t></t><k>private</k> <k>int</k> <f>age</f>; <c>// this field will be ignored</c> <br>
	}
</code>
</p>
<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		UserEntity <v>user</v> = ...; <br>
		Mapper.<i>get</i>().serialize(<v>user</v>); <c>// result: {user_id=0, name=null}</c>
	</code>
</p>

<p>
	One entity can be serialized in more ways that are defined by string key. This key is the second (optional) parameter to <code>serialize</code> method. <code>MapperIgnore</code> contains array of strings. If one of then is equals to given key, field will be ignored. If the array is empty (default state), field will be always ignored. Otherwise will be used. <code>MapperParameter</code> can has more than one <code>MapperType</code>. <code>MapperType</code> has <code>key</code> parameter that specified the 'way'. Default is empty string and means 'use if no others options'.
</p>
 
<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	<k>public class</k> UserEntity { <br>
		<t></t><d>@MapperParameter</d>({<d>@MapperType</d>(value=<w>"user_id"</w>, key=<w>"KeyA"</w>), <d>@MapperType</d>(value=<w>"userId"</w>, key=<w>"KeyB"</w>)}) <br>
		<t></t><k>private</k> <k>int</k> <f>id</f>; <br>
		<t></t><d>@MapperParameter</d>({<d>@MapperType</d>(value=<w>"userName"</w>), @MapperType(value=<w>"Name"</w>, key=<w>"KeyA"</w>)}) <br>
		<t></t><k>private</k> String <f>name</f>;<br>
		<t></t><d>@MapperIgnored</d>({<w>"KeyA"</w>}) <br>
		<t></t><k>private</k> <k>int</k> <f>age</f>; <c>// this field will be ignored</c> <br>
	}
</code>
</p>

<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		UserEntity <v>user</v> = ...; <br>
		Mapper.<i>get</i>().serialize(<k>new</k> MapperEndToEndTest(), <w>"KeyA"</w>) <c>// result: {user_id=0, Name=null}</c><br>
		Mapper.<i>get</i>().serialize(<k>new</k> MapperEndToEndTest(), <w>"KeyB"</w>)<c>// result: {userName=null, userId=0, age=0}</c><br>
		Mapper.<i>get</i>().serialize(<k>new</k> MapperEndToEndTest(), <w>"KeyC"</w>)<c>// result: {id=0, userName=null, age=0}</c><br>
		Mapper.<i>get</i>().serialize(<k>new</k> MapperEndToEndTest())<c>// result: {id=0, userName=null, age=0}</c>
	</code>
</p>

<p class="alert alert-warning">
	<strong>NOTE:</strong> If you use general rule (no key) and rule(s) with key, define the general rule as first. See annotations on <code>name</code> parameter.
</p>


<h3>Parsing</h3>

<p>
	Parsing is reverse of serialize. From <code>Map</code> create entity (Or from list of map, result will be list of entity). During serialization JI come thru all fields of entity and try finds for it value in <code>Map</code>. As key is used field name. If you do not wish use field name as key, you need to annotate this field with <code>MapperParameter</code> and as value to put <code>MapperType</code> (see examples). Parsing works recursively.
</p>

<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	<k>public class</k> UserEntity { <br>
		<t></t><d>@MapperParameter</d>({<d>@MapperType</d>(<w>"user_id"</w>)}) <br>
		<t></t><k>private int</k> <f>id</f>; <c>// this field will be loaded from 'user_id'</c> <br>
		<t></t> <br>
		<t></t><k>private</k> String <f>name</f>; <c>// this field will be loaded from 'name'</c> <br>
	}
</code>
</p>
<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		Map&lt;String, Object&gt; <v>map</v> = <k>new</k> HashMap&lt;&gt;(); <br>
		<v>map</v>.put(<w>"user_id"</w>, 42); <br>
		<v>map</v>.put(<w>"name"</w>, <w>"Name #42"</w>); <br>
		Mapper.<i>get</i>().parse(UserEntity.<k>class</k>, <v>map</v>);
	</code>
</p>

<p>
	One entity can be parsed in more ways that are defined by string key. This key is the second (optional) parameter to <code>parse</code> method. <code>MapperParameter</code> can has more than one <code>MapperType</code>. <code>MapperType</code> has <code>key</code> parameter that specified the 'way'. Default is empty string and means 'use if no others options'.
</p>
 
<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	<k>public class</k> UserEntity { <br>
		<t></t><d>@MapperParameter</d>({<d>@MapperType</d>(value=<w>"user_id"</w>, key=<w>"KeyA"</w>), <d>@MapperType</d>(value=<w>"userId"</w>, key=<w>"KeyB"</w>)}) <br>
		<t></t><k>private int</k> <f>id</f>; <br>
		<t></t><d>@MapperParameter</d>({<d>@MapperType</d>(value=<w>"userName"</w>), <d>@MapperType</d>(value=<w>"Name"</w>, key=<w>"KeyA"</w>)}) <br>
		<t></t><k>private</k> String <f>name<f>;<br>
	}
</code>
</p>

<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		Map&lt;String, Object&gt; <v>map</v> = <k>new</k> HashMap&lt;&gt;();
		<v>map</v>.put(<w>"user_id"</w>, 42); <br>
		<v>map</v>.put(<w>"userId"</w>, 24); <br>
		<v>map</v>.put(<w>"id"</w>, 1); <br>
		<v>map</v>.put(<w>"name"</w>, <w>"Name #42"</w>); <br>
		<v>map</v>.put(<w>"Name"</w>, <w>"Name #24"</w>); <br>
		<v>map</v>.put(<w>"userName"</w>, <w>"Name #1"</w>); <br>
		Mapper.<i>get</i>().parse(UserEntity.<k>class</k>, <w>"KeyA"</w>) <c>// result: id=42, name="Name #24"</c><br>
		Mapper.<i>get</i>().parse(UserEntity.<k>class</k>, <w>"KeyB"</w>)<c>// result: id=24, name="Name #1"</c><br>
		Mapper.<i>get</i>().parse(UserEntity.<k>class</k>, <w>"KeyC"</w>)<c>// result:id=1, name="Name #1"</c><br>
		Mapper.<i>get</i>().parse(UserEntity.<k>class</k>)<c>// result: id=1, name="Name #1"</c>
	</code>
</p>

<p class="alert alert-warning">
	<strong>NOTE:</strong> If you use general rule (no key) and rule(s) with key, define the general rule as first. See annotations on <code>name</code> parameter.
</p>


<h2>Other</h2>

<h3>Env</h3>

<p>
	Application configuration. Can be loaded from file using <code>PropertiesLoader</code>. Works like <code>MapDirectory</code>, so you can get variables with type.
</p>
<p class="alert alert-dark code">
	<code>
		Env <v>env</v> = <k>new</k> Env(<w>"conf/app.properties"</w>); <br>
		<c>// or alternativelly</c> <br>
		Properties <v>prop</v> = ...; <br>
		Env <v>env2</v> = <d>new</d> Env(<v>prop</k>); <br>
	</code>
</p>

<h3>Implode</h3>

<p>
	Array or <code>Iterable</code> to string with given glue and optionally with to-string function applied on each item.
</p>
<p class="alert alert-dark code">
	<code>
		Implode.<i>implode</i>(<w>", "</w>, 1, 2, 3); <c> // returns "1, 2, 3"</c> <br>
		Implode.<i>implode</i>(<v>i</v>-><v>i</v>+<w>"0"</w>, <w>", "</w>, 1, 2, 3); <c> // returns "10, 20, 30"</c> <br>
		Implode.<i>implode</i>(<w>", "</w>, Arrays.asList(1, 2, 3)); <c> // returns "1, 2, 3"</c> <br>
		Implode.<i>implode</i>(<v>i</v>-><v>i</v>+<w>"0"</w>, <w>", "</w>, Arrays.asList(1, 2, 3)); <c> // returns "10, 20, 30"</c> <br>
	</code>
</p>