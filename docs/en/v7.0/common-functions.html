<h1>Functions</h1>

<h2>Files and IO functions</h2>

<h3>FileExcension</h3>

<p>
	Splits file name to name and extension:
</p>
<p class="code">
	<code>
		FileExtension ext = new FileExtension(<span class="text">"some-name.txt"</span>); <br>
		String name = ext.getName();<br>
		String extension = ext.getExtension();
	</code>
</p>

<h3>FilesList</h3>

<p>
	Loads file names from directory. Can be recursive or not. Is able to load names from directory in file system and from jar file.
</p>
<p class="code">
	<code>
		FilesList filesList = FilesList.get(<span class="text">"/path/to/dir/name"</span>, true); <span class="comment">// second parameter says 'recursive'</span> <br>
		List&lt;String&gt; files = filesList.getFiles(); <br>
		URL url = filesList.getURL();
	</code>
</p>

<h3>InputStreamLoader</h3>

<p>
	Creates new instance of <code>InputStream</code> from file. File can be in file system, classpath (in IDE) or in jar. <strong>Path to file has to be relative without first '/'.</strong> 
</p>
<p class="code">
	<code>
		InputStream inputStream = InputStreamLoader.createInputStream(this.getClass(), <span class="text">"path/to/file"</span>);
	</code>
</p>

<h3>PropertiesLoader</h3>

<p>
	Loads <code>Properties</code> from file using <code>InputStreamLoader</code> (means file can be in file system or jar).
</p>
<p class="code">
	<code>
		Properties prop = PropertiesLoader.loadProperties(<span class="text">"res/app.properties"</span>); <br>
		<span class="comment">// optionally with charset, default 'uft-8'</span> <br>
		Properties prop = PropertiesLoader.loadProperties(<span class="text">"res/app.properties"</span>, <span class="text">"windows-1250"</span>);
	</code>
</p>

<h2>Mapper</h2>

<p>
	<code>Mapper</code> class is able to convert object (entity) to <code>Map</code> (serialize) and <code>Map</code> back to entity (parse).
</p>

<h3>Serialize</h3>

<p>
	During serialization JI come thru all fields of entity and uses then as key in new <code>Map</code>. Values of fields become values. Serializations works recursivelly. If you wish ignore field during serialization, just add <code>MapperIgnored</code> annotation. If you do not wish use field name as key, you need to annotate this field with <code>MapperParameter</code> and as value to put <code>MapperType</code> (see examples).
</p>

<strong>Entity</strong>
<p class="code">
<code>
	public class UserEntity { <br>
<span class="tab"></span>@MapperParameter({@MapperType(<span class="text">user_id</span>)}) <br>
<span class="tab"></span>private int id; <span class="comment"> // this field will be saved as 'user_id'</span> <br>
<span class="tab"></span> <br>
<span class="tab"></span>private String name; <span class="comment"> // this field will be saved as 'name'</span> <br>
<span class="tab"></span>@MapperIgnored <br>
<span class="tab"></span>private int age; <span class="comment"> // this field will be ignored</span> <br>
	}
</code>
</p>
<strong>Call:</strong>
<p class="code">
	<code>
		UserEntity user = ...; <br>
		Mapper.get().serialize(user);
	</code>
</p>

<p>
	One entity can be serialized in more ways that are defined by string key. This key is the second (optional) parameter to <code>serialize</code> method. <code>MapperIgnore</code> contains array of strings. If one of then is equals to given key, field will be ignored. If the array is empty (default state), field will be always ignored. Otherwise will be used. <code>MapperParameter</code> can has more than one <code>MapperType</code>. <code>MapperType</code> has <code>key</code> parameter that specified the 'way'. Default is empty string and means 'use if no others options'.
</p>
 
TODO generate example


<h2>Other</h2>

<h3>Env</h3>

<p>
	Application configuration. Can be loaded from file using <code>PropertiesLoader</code>. Works like <code>MapDirectory</code>, so you can get variables with type.
</p>
<p class="code">
	<code>
		Env env = new Env(<span class="text">"conf/app.properties"</span>); <br>
		<span class="comment">// or alternativelly</span> <br>
		Properties prop = ...; <br>
		Env env2 = new Env(prop); <br>
	</code>
</p>

<h3>Implode</h3>

<p>
	Array or <code>Iterable</code> to string with given glue and optionally with to-string function applied on each item.
</p>
<p class="code">
	<code>
		Implode.implode(<span class="text">", "</span>, 1, 2, 3); <span class="comment"> // returns "1, 2, 3"</span> <br>
		Implode.implode(i->i+<span class="text">"0"</span>, <span class="text">", "</span>, 1, 2, 3); <span class="comment"> // returns "10, 20, 30"</span> <br>
		Implode.implode(<span class="text">", "</span>, Arrays.asList(1, 2, 3)); <span class="comment"> // returns "1, 2, 3"</span> <br>
		Implode.implode(i->i+<span class="text">"0"</span>, <span class="text">", "</span>, Arrays.asList(1, 2, 3)); <span class="comment"> // returns "10, 20, 30"</span> <br>
	</code>
</p>