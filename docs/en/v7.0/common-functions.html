<h1>Functions</h1>

<h2>Files and IO functions</h2>

<h3>FileExcension</h3>

<p>
	Splits file name to name and extension:
</p>
<p class="alert alert-dark code">
	<code>
		FileExtension <span class="variable">ext</span> = <span class="keyword">new</span> FileExtension(<span class="text">"some-name.txt"</span>); <br>
		String <span class="variable">name</span> = <span class="variable">ext</span>.getName();<br>
		String <span class="variable">extension</span> = <span class="variable">ext</span>.getExtension();
	</code>
</p>

<h3>FilesList</h3>

<p>
	Loads file names from directory. Can be recursive or not. Is able to load names from directory in file system and from jar file.
</p>
<p class="alert alert-dark code">
	<code>
		FilesList <span class="variable">filesList</span> = FilesList.get(<span class="text">"/path/to/dir/name"</span>, true); <span class="comment">// second parameter says 'recursive'</span> <br>
		List&lt;String&gt; files = filesList.getFiles(); <br>
		URL url = filesList.getURL();
	</code>
</p>

<h3>InputStreamLoader</h3>

<p>
	Creates new instance of <code>InputStream</code> from file. File can be in file system, classpath (in IDE) or in jar. <strong>Path to file has to be relative without first '/'.</strong> 
</p>
<p class="alert alert-dark code">
	<code>
		InputStream inputStream = InputStreamLoader.createInputStream(this.getClass(), <span class="text">"path/to/file"</span>);
	</code>
</p>

<h3>PropertiesLoader</h3>

<p>
	Loads <code>Properties</code> from file using <code>InputStreamLoader</code> (means file can be in file system or jar).
</p>
<p class="alert alert-dark code">
	<code>
		Properties prop = PropertiesLoader.loadProperties(<span class="text">"res/app.properties"</span>); <br>
		<span class="comment">// optionally with charset, default 'uft-8'</span> <br>
		Properties prop = PropertiesLoader.loadProperties(<span class="text">"res/app.properties"</span>, <span class="text">"windows-1250"</span>);
	</code>
</p>

<h2>Mapper</h2>

<p>
	<code>Mapper</code> class is able to convert object (entity) to <code>Map</code> (serialize) and <code>Map</code> back to entity (parse).
</p>

<h3>Serialize</h3>

<p>
	During serialization JI come thru all fields of entity and uses then as key in new <code>Map</code>. Values of fields become values. Serializations works recursivelly. If you wish ignore field during serialization, just add <code>MapperIgnored</code> annotation. If you do not wish use field name as key, you need to annotate this field with <code>MapperParameter</code> and as value to put <code>MapperType</code> (see examples).
</p>

<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	public class UserEntity { <br>
<span class="tab"></span>@MapperParameter({@MapperType(<span class="text">"user_id"</span>)}) <br>
<span class="tab"></span>private int id; <span class="comment"> // this field will be saved as 'user_id'</span> <br>
<span class="tab"></span> <br>
<span class="tab"></span>private String name; <span class="comment"> // this field will be saved as 'name'</span> <br>
<span class="tab"></span>@MapperIgnored <br>
<span class="tab"></span>private int age; <span class="comment"> // this field will be ignored</span> <br>
	}
</code>
</p>
<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		UserEntity user = ...; <br>
		Mapper.get().serialize(user); <span class="comment">// result: {user_id=0, name=null}</span>
	</code>
</p>

<p>
	One entity can be serialized in more ways that are defined by string key. This key is the second (optional) parameter to <code>serialize</code> method. <code>MapperIgnore</code> contains array of strings. If one of then is equals to given key, field will be ignored. If the array is empty (default state), field will be always ignored. Otherwise will be used. <code>MapperParameter</code> can has more than one <code>MapperType</code>. <code>MapperType</code> has <code>key</code> parameter that specified the 'way'. Default is empty string and means 'use if no others options'.
</p>
 
<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	public class UserEntity { <br>
<span class="tab"></span>@MapperParameter({@MapperType(value=<span class="text">"user_id"</span>, key=<span class="text">"KeyA"</span>), @MapperType(value=<span class="text">"userId"</span>, key=<span class="text">"KeyB"</span>)}) <br>
<span class="tab"></span>private int id; <br>
<span class="tab"></span>@MapperParameter({@MapperType(value=<span class="text">"userName"</span>), @MapperType(value=<span class="text">"Name"</span>, key=<span class="text">"KeyA"</span>)}) <br>
<span class="tab"></span>private String name;<br>
<span class="tab"></span>@MapperIgnored({<span class="text">"KeyA"</span>}) <br>
<span class="tab"></span>private int age; <span class="comment"> // this field will be ignored</span> <br>
	}
</code>
</p>

<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		UserEntity user = ...; <br>
		Mapper.get().serialize(<span class="keyword">new</span> MapperEndToEndTest(), <span class="test">"KeyA"</span>) <span class="comment">// result: {user_id=0, Name=null}</span><br>
		Mapper.get().serialize(<span class="keyword">new</span> MapperEndToEndTest(), <span class="test">"KeyB"</span>)<span class="comment">// result: {userName=null, userId=0, age=0}</span><br>
		Mapper.get().serialize(<span class="keyword">new</span> MapperEndToEndTest(), <span class="test">"KeyC"</span>)<span class="comment">// result: {id=0, userName=null, age=0}</span><br>
		Mapper.get().serialize(<span class="keyword">new</span> MapperEndToEndTest())<span class="comment">// result: {id=0, userName=null, age=0}</span>
	</code>
</p>

<p class="alert alert-warning">
	<strong>NOTE:</strong> If you use general rule (no key) and rule(s) with key, define the general rule as first. See annotations on <code>name</code> parameter.
</p>


<h3>Parsing</h3>

<p>
	Parsing is reverse of serialize. From <code>Map</code> create entity (Or from list of map, result will be list of entity). During serialization JI come thru all fields of entity and try finds for it value in <code>Map</code>. As key is used field name. If you do not wish use field name as key, you need to annotate this field with <code>MapperParameter</code> and as value to put <code>MapperType</code> (see examples). Parsing works recursively.
</p>

<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	public class UserEntity { <br>
<span class="tab"></span>@MapperParameter({@MapperType(<span class="text">"user_id"</span>)}) <br>
<span class="tab"></span>private int id; <span class="comment"> // this field will be loaded from 'user_id'</span> <br>
<span class="tab"></span> <br>
<span class="tab"></span>private String name; <span class="comment"> // this field will be loaded from 'name'</span> <br>
	}
</code>
</p>
<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		Map<String, Object> map = <span class="keyword">new</span> HashMap&lt;&gt;(); <br>
		map.put(<span class="text">"user_id"</span>, 42); <br>
		map.put(<span class="text">"name"</span>, <span class="text">"Name #42"</span>); <br>
		Mapper.get().parse(UserEntity.class, map);
	</code>
</p>

<p>
	One entity can be parsed in more ways that are defined by string key. This key is the second (optional) parameter to <code>parse</code> method. <code>MapperParameter</code> can has more than one <code>MapperType</code>. <code>MapperType</code> has <code>key</code> parameter that specified the 'way'. Default is empty string and means 'use if no others options'.
</p>
 
<strong>Entity</strong>
<p class="alert alert-dark code">
<code>
	public class UserEntity { <br>
<span class="tab"></span>@MapperParameter({@MapperType(value=<span class="text">"user_id"</span>, key=<span class="text">"KeyA"</span>), @MapperType(value=<span class="text">"userId"</span>, key=<span class="text">"KeyB"</span>)}) <br>
<span class="tab"></span>private int id; <br>
<span class="tab"></span>@MapperParameter({@MapperType(value=<span class="text">"userName"</span>), @MapperType(value=<span class="text">"Name"</span>, key=<span class="text">"KeyA"</span>)}) <br>
<span class="tab"></span>private String name;<br>
	}
</code>
</p>

<strong>Call:</strong>
<p class="alert alert-dark code">
	<code>
		Map<String, Object> <span class="variable">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();
		<span class="variable">map</span>.put(<span class="text">"user_id"</span>, 42); <br>
		<span class="variable">map</span>.put(<span class="text">"userId"</span>, 24); <br>
		<span class="variable">map</span>.put(<span class="text">"id", 1); <br>
		<span class="variable">map</span>.put(<span class="text">"name"</span>, <span class="text">"Name #42"</span>); <br>
		<span class="variable">map</span>.put(<span class="text">"Name"</span>, <span class="text">"Name #24"</span>); <br>
		<span class="variable">map</span>.put(<span class="text">"userName"</span>, <span class="text">"Name #1"</span>); <br>
		Mapper.get().parse(UserEntity.class, <span class="test">"KeyA"</span>) <span class="comment">// result: id=42, name="Name #24"</span><br>
		Mapper.get().parse(UserEntity.class, <span class="test">"KeyB"</span>)<span class="comment">// result: id=24, name="Name #1"</span><br>
		Mapper.get().parse(UserEntity.class, <span class="test">"KeyC"</span>)<span class="comment">// result:id=1, name="Name #1"</span><br>
		Mapper.get().parse(UserEntity.class)<span class="comment">// result: id=1, name="Name #1"</span>
	</code>
</p>

<p class="alert alert-warning">
	<strong>NOTE:</strong> If you use general rule (no key) and rule(s) with key, define the general rule as first. See annotations on <code>name</code> parameter.
</p>


<h2>Other</h2>

<h3>Env</h3>

<p>
	Application configuration. Can be loaded from file using <code>PropertiesLoader</code>. Works like <code>MapDirectory</code>, so you can get variables with type.
</p>
<p class="alert alert-dark code">
	<code>
		Env env = <span class="keyword">new</span> Env(<span class="text">"conf/app.properties"</span>); <br>
		<span class="comment">// or alternativelly</span> <br>
		Properties prop = ...; <br>
		Env env2 = <span class="keyword">new</span> Env(prop); <br>
	</code>
</p>

<h3>Implode</h3>

<p>
	Array or <code>Iterable</code> to string with given glue and optionally with to-string function applied on each item.
</p>
<p class="alert alert-dark code">
	<code>
		Implode.implode(<span class="text">", "</span>, 1, 2, 3); <span class="comment"> // returns "1, 2, 3"</span> <br>
		Implode.implode(i->i+<span class="text">"0"</span>, <span class="text">", "</span>, 1, 2, 3); <span class="comment"> // returns "10, 20, 30"</span> <br>
		Implode.implode(<span class="text">", "</span>, Arrays.asList(1, 2, 3)); <span class="comment"> // returns "1, 2, 3"</span> <br>
		Implode.implode(i->i+<span class="text">"0"</span>, <span class="text">", "</span>, Arrays.asList(1, 2, 3)); <span class="comment"> // returns "10, 20, 30"</span> <br>
	</code>
</p>