<h1>JSON</h1>

<p>
	JI Files provides two ways how to work with JSON - directly write to/read from JSON stream and automatic file read from/write to objects.
</p>

<h2>JSON stream</h2>

<p>With JSON stream you write/read JSON parts one by one. JI see JSON as objects (<code>{}</code>), lists (<code>[]</code>) and items (values). All three entities can have their name, if they are inside object. Objects and lists have start and end.</p>

<h3>OutpuJsonStream</h3>

<p>
	For creating <code>OutputJsonStream</code> you need <code>OutputProvider</code> (see below) and (optionally) <code>boolean</code> parameter <code>formated</code> (switch, if print human-readable or not. Default false). <code>OutputJsonStream</code> is closable. The <code>close</code> method close <code>OutputProvider</code>.
</p>

<strong>API</strong>
<p class="alert alert-dark code"><code>
	<c>// object start - '{' - in list or empty file</span> <br>
	stream.writeObjectStart(); <br>
	<c>// object start - '{' - in object</span> <br>
	stream.writeObjectStart(name); <br>
	<c>// object end - '}'</span> <br>
	stream.writeObjectEnd(); <br>

	<c>// list start - '[' - in list or empty file</span> <br>
	stream.writeListStart(); <br>
	<c>// list start - '[' - in object</span> <br>
	stream.writeListStart(name); <br>
	<c>// list end - ']'</span> <br>
	stream.writeListEnd(); <br>


	<c>// primitive or String value - in list</span> <br>
	stream.writeListValue(value); <br>
	<c>// primitive or String value - in object</span> <br>
	stream.writeObjectValue(name, value); <br>
</code></p>

<strong>Example: construct</strong>
<p class="alert alert-dark code"><code>
	OutputProvider provider = ...; <br>
	OutputJsonStream stream = <span class="keyword">new</span> OutputJsonStream(provider); <br>
	<c>// your code</span>
	stream.close(); <br>
</code></p>

<strong>Example: writing</strong>

<p><code>
{ <br>
<t/>"item1": 123,<br>
<t/>"item2": "value",<br>
<t/>"item-list": [ <br>
<t/><t/>"one", <br>
<t/><t/>2, <br>
<t/><t/>false, <br>
<t/><t/>NULL <br>
<t/>],<br>
<t/>"item-object": { <br>
<t/><t/>"subItem": "value" <br>
<t/>} <br>
}
</code></p>

<p class="alert alert-dark code"><code>
	stream.writeObjectStart(); <br>
	stream.writeObjectValue(<w>"item1"</span>, 123); <br>
	stream.writeObjectValue(<w>"item2"</span>, <w>"value"</span>); <br>
	stream.writeListStart(<w>"item-list"</span>); <br>
	stream.writeListValue(<w>"one"</span>); <br>
	stream.writeListValue(2); <br>
	stream.writeListValue(false); <br>
	stream.writeListValue(null); <br>
	stream.writeListEnd(); <br>
	stream.writeObjectStart(<w>"item-object"</span>); <br>
	stream.writeObjectItem(<w>"subItem"</span>, <w>"value"</span>); <br>
	stream.writeObjectEnd(); <br>
	stream.writeObjectEnd();
</code></p>

<h4>OutputProvider</h4>

<p>
	Write data. JI Files contains two implementations:

	<ul>
		<li><code>OutputStringProvider</code>: write JSON into <code>String</code>. The result is available on <code>getJson</code> method.</li>
		<li><code>OutputWriterProvider</code>: write JSON into given <code>Writer</code>. The <code>OutputWriterProvider::close()</code> close <code>Writer</code>.</li>
	</ul>
</p>

<h3>InputJsonStream</h3>

<p>
	For creating <code>InputJsonStream</code> you need <code>InputProvider</code> (see below). The stream is controlled with <code>next</code>method<code>. This method returns <code>Event</code> that provide you all required information. InputJsonStream</code> is closable. The <code>close</code> method close <code>InputProvider</code>.
</p>

<strong>Event</strong>
<p>
	The <code>Event</code> contains <code>EventType</code>, name (<code>null</code> if no name), <code>Value</code> and <code>int</code> level.
</p>

<strong>Value</strong>
<p>
	The <code>Code</code> holds JSON item value and <code>ValueType</code> (<code>NULL</code>, <code>BOOLEAN</code>, <code>INTEGER</code>, <code>DOUBLE</code> and <code>String</code>).
</p>

<strong>Example: construct</strong>
<p class="alert alert-dark code"><code>
	InputProvider provider = ...; <br>
	InputJsonStream stream = <span class="keyword">new</span> InputJsonStream(provider); <br>
	<c>// your code</span> <br>
	stream.close(); <br>
</code></p>

<strong>Example: reading</strong>
<p class="alert alert-dark code"><code>
	<c>// reading is more general, does not requried JSON example</span> <br>
	Event e = stream.next(); <br>
	while(e.hasNext()) { <br>
	<t/><c>// your code</span> <br>
	<t/>e = stream.next(); <br>
	} <br>
</code></p>

<h4>InputProvider</h4>

<p>
	Read data. JI Files contains two implementations:

	<ul>
		<li><code>InputStringProvider</code>: provide data from given String</li>
		<li><code>InputReaderProvider</code>: read data from given <code>Reader</code>. The <code>InputReaderProvider::close()</code> close <code>Reader</code>.</li>
	</ul>
</p>

<h2>JsonWriter</h2>

<p>
	Write any <code>Object</code> to JSON stream.
</p>

<p class="alert alert-dark code"><code>
	Object <v>data</span> = ...; <br>
	<c>// create JSON and returns it as string</span> <br>
	String json = <span class="keyword">new</span> JsonWritter().write(<v>data</span>); <br>
	<c>// write JSON to given OutputJsonStream</span> <br>
	OutputJsonStream <v>stream</span> = ...; <br>
	<span class="keyword"><span class="keyword">new</span></span> JsonWritter().write(<v>stream</span>, <v>data</span>);<br>
</code></p>

<p>
	The object will be written with following rules:
	<ul>
		<li><code>NULL</code> is <code>null</code></li>
		<li><code>Iterable</code> and <code>ListDictionary</code> are JSON list</li>
		<li><code>Map</code> and <code>MapDictionary</code> are JSON object</li>
		<li><code>Jsonable</code> (see bellow) - the final JSON is defined by <code>toJson</code> method</li>
		<li><code>Boolean</code> and <code>Number</code> are written with <code>toString</code> without quotes</li>
		<li>
			<code>Character</code>, <code>String</code>, <code>Enum</code>, <code>LocalDateTime</code>, 
			<code>ZonedDateTime</code>, <code>LocalTime</code>, <code>LocalDate</code> and <code>Date</code> are written as text with quotes
		</li>
		<li><code>DictionaryValue</code> is written as its value</li>
		<li><code>Optional</code> - if present, the value is written, otherwise <code>null</code></li>
		<li>Any other classes are serialized with JI Common <code>Mapper</code></li>
	</ul>
</p>

<p class="alert alert-danger">
	<strong>NOTE:</strong> serializing some native classes with <code>Mapper</code> can cause infinite recursion.
</p>

<h3>Jsonable</h3>

<p>
	This interface allow you define how to parse your object to JSON. <code>toJson</code> returns object and the rules upper will be applied on it.
</p>

<h2>JsonReader</h2>

<p>
	Reads from JSON stream and returns <code>Object</code>. JSON list is <code>List</code>, JSON object is <code>Map</code>.If target class is specified, returns new instance of that class (using <code>Mapper</code>).
</p>

<p class="alert alert-dark code"><code>
	<c>// parse from string</c> <br>
	String <v>json</v> = ...; <br>
	Object <v>parsedJson</v> = <k>new</k> JsonReader().read(<v>json</v>); <br>

	<c>// parse from stream</c> <br>
	InputJsonStream <v>jsonStream</v> = ...; <br>
	Object <v>parsedJsonStream</v> = <k>new</k> JsonReader().read(<v>jsonStream</v>); <br>

	<c>// parse from json to MyClass</c> <br>
	String <v>json</v> = ...; <br>
	MyClass <v>myClassFromString</v> = <k>new</k> JsonReader().read(<v>json</v>, MyClass.<k>class</k>); <br>

	<c>// parse from stream to MyClass</c> <br>
	InputJsonStream <v>jsonStream</v> = ...; <br>
	MyClass <v>myClassFromStream</v> = <k>new</k> JsonReader().read(<v>jsonStream</v>, MyClass.<k>class</k>); <br>
</code></p>